#!/usr/bin/env node

import { spawn } from 'child_process';
import { networkInterfaces } from 'os';
import { writeFileSync, readFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { get } from 'http';

const __dirname = dirname(fileURLToPath(import.meta.url));

// Colors for console output
const colors = {
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  reset: '\x1b[0m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

/**
 * Get the local network IP address
 */
function getNetworkIP() {
  const interfaces = networkInterfaces();
  const priorities = ['en0', 'eth0', 'wlan0', 'Wi-Fi', 'Ethernet'];
  
  // Try priority interfaces first
  for (const name of priorities) {
    if (interfaces[name]) {
      const ipv4 = interfaces[name].find(
        (iface) => iface.family === 'IPv4' && !iface.internal
      );
      if (ipv4) {
        return ipv4.address;
      }
    }
  }
  
  // Fallback to any available IPv4 address
  for (const name in interfaces) {
    const iface = interfaces[name];
    const ipv4 = iface.find(
      (i) => i.family === 'IPv4' && !i.internal
    );
    if (ipv4) {
      return ipv4.address;
    }
  }
  
  return null;
}

/**
 * Update or create .env file with the network IP
 */
function updateEnvFile(ip) {
  const envPath = join(__dirname, '..', '.env');
  let envContent = '';
  
  if (existsSync(envPath)) {
    envContent = readFileSync(envPath, 'utf-8');
  }
  
  const viteApiHostRegex = /^VITE_API_HOST=.*$/m;
  
  if (viteApiHostRegex.test(envContent)) {
    envContent = envContent.replace(viteApiHostRegex, `VITE_API_HOST=${ip}`);
  } else {
    if (envContent && !envContent.endsWith('\n')) {
      envContent += '\n';
    }
    envContent += `VITE_API_HOST=${ip}\n`;
  }
  
  writeFileSync(envPath, envContent);
  log(`âœ… Updated .env with VITE_API_HOST=${ip}`, 'green');
}

/**
 * Update the API config file in the UI package
 */
function updateApiConfig(ip) {
  const configPath = join(__dirname, '..', '..', '..', 'packages', 'ui', 'src', 'lib', 'api-config.ts');
  const configContent = `// This file is auto-generated by the mobile dev scripts
// DO NOT EDIT MANUALLY - it will be overwritten

export const API_CONFIG = {
  baseUrl: 'http://${ip}:3000'
};`;
  
  writeFileSync(configPath, configContent);
  log(`âœ… Updated api-config.ts with network IP`, 'green');
}

/**
 * Check if backend is accessible
 */
function checkBackend(ip) {
  return new Promise((resolve) => {
    const options = {
      hostname: ip,
      port: 3000,
      path: '/',
      method: 'GET',
      timeout: 2000
    };

    const req = get(options, (res) => {
      resolve(true);
    });

    req.on('error', () => {
      resolve(false);
    });

    req.on('timeout', () => {
      req.destroy();
      resolve(false);
    });
  });
}

/**
 * Start the backend server
 */
function startBackend() {
  return new Promise((resolve) => {
    log('ðŸš€ Starting backend server...', 'yellow');
    
    const webPath = join(__dirname, '..', '..', 'web');
    const child = spawn('pnpm', ['dev:network'], {
      cwd: webPath,
      stdio: 'pipe',
      shell: true
    });
    
    let backendStarted = false;
    
    // Listen for output to detect when server is ready
    child.stdout.on('data', (data) => {
      const output = data.toString();
      console.log(`[Backend] ${output.trim()}`);
      
      // Check if server is ready
      if (output.includes('Ready in') || output.includes('started server on')) {
        if (!backendStarted) {
          backendStarted = true;
          log('âœ… Backend server started successfully', 'green');
          // Give it a moment to fully initialize
          setTimeout(() => resolve(child), 1000);
        }
      }
    });
    
    child.stderr.on('data', (data) => {
      console.error(`[Backend Error] ${data.toString().trim()}`);
    });
    
    child.on('error', (error) => {
      log(`âŒ Failed to start backend: ${error.message}`, 'red');
      resolve(null);
    });
    
    // Timeout after 30 seconds
    setTimeout(() => {
      if (!backendStarted) {
        log('âš ï¸  Backend startup timeout', 'yellow');
        resolve(child);
      }
    }, 30000);
  });
}

/**
 * Run Tauri command
 */
function runTauri(platform, ip) {
  const command = 'pnpm';
  const args = ['tauri', platform, 'dev'];
  
  log(`ðŸ“± Starting ${platform} development...`, 'yellow');
  
  // Make sure the environment variable is set
  const env = {
    ...process.env,
    VITE_API_HOST: ip,
    // Also set for Tauri's use
    TAURI_DEV_HOST: ip
  };
  
  const child = spawn(command, args, {
    stdio: 'inherit',
    shell: true,
    env
  });
  
  child.on('error', (error) => {
    log(`âŒ Error: ${error.message}`, 'red');
    process.exit(1);
  });
  
  child.on('exit', (code) => {
    if (code !== 0) {
      log(`âŒ Process exited with code ${code}`, 'red');
      process.exit(code);
    }
  });
}

// Main execution
async function main() {
  const platform = process.argv[2];
  
  if (!platform || !['ios', 'android'].includes(platform)) {
    log('âŒ Please specify platform: ios or android', 'red');
    log('Usage: node scripts/dev-mobile.js [ios|android]');
    process.exit(1);
  }
  
  log('ðŸ” Detecting network IP address...', 'yellow');
  
  const ip = getNetworkIP();
  
  if (!ip) {
    log('âŒ Could not detect network IP address', 'red');
    log('Please set VITE_API_HOST manually in .env file');
    process.exit(1);
  }
  
  log(`ðŸŒ Detected network IP: ${ip}`, 'green');
  updateEnvFile(ip);
  updateApiConfig(ip);
  
  // Set environment variable for current process
  process.env.VITE_API_HOST = ip;
  
  // Check backend
  log('ðŸ”— Checking backend connection...', 'yellow');
  const backendAccessible = await checkBackend(ip);
  
  let backendProcess = null;
  
  if (backendAccessible) {
    log('âœ… Backend is accessible', 'green');
  } else {
    log(`âš ï¸  Backend at http://${ip}:3000 is not accessible`, 'yellow');
    log('ðŸ¤” Starting backend automatically...', 'yellow');
    
    backendProcess = await startBackend();
    
    if (backendProcess) {
      // Wait a bit more and check again
      await new Promise(resolve => setTimeout(resolve, 2000));
      const backendNowAccessible = await checkBackend(ip);
      
      if (!backendNowAccessible) {
        log('âš ï¸  Backend started but still not accessible', 'yellow');
        log('   You may need to check firewall settings', 'yellow');
      }
    } else {
      log('âŒ Failed to start backend automatically', 'red');
      log('   Please run manually: cd ../web && pnpm dev:network', 'yellow');
    }
  }
  
  // Run Tauri
  runTauri(platform, ip);
  
  // Handle cleanup
  process.on('SIGINT', () => {
    if (backendProcess) {
      log('\nðŸ›‘ Stopping backend server...', 'yellow');
      backendProcess.kill();
    }
    process.exit(0);
  });
}

main();